'''Name : Garvit Verma   Roll no.: B20098
Contact no.: 8272840777'''

import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
from os import error
from sklearn.decomposition import PCA

df=pd.read_csv("pima-indians-diabetes.csv")

# Q1
q1_pregs=df['pregs'].quantile(.25)
q3_pregs=df['pregs'].quantile(.75)
iqr_pregs=q3_pregs-q1_pregs

q1_plas=df['plas'].quantile(.25)
q3_plas=df['plas'].quantile(.75)
iqr_plas=q3_plas-q1_plas

q1_pres=df['pres'].quantile(.25)
q3_pres=df['pres'].quantile(.75)
iqr_pres=q3_pres-q1_pres

q1_skin=df['skin'].quantile(.25)
q3_skin=df['skin'].quantile(.75)
iqr_skin=q3_skin-q1_skin

q1_test=df['test'].quantile(.25)
q3_test=df['test'].quantile(.75)
iqr_test=q3_test-q1_test

q1_BMI=df['BMI'].quantile(.25)
q3_BMI=df['BMI'].quantile(.75)
iqr_BMI=q3_BMI-q1_BMI

q1_pedi=df['pedi'].quantile(.25)
q3_pedi=df['pedi'].quantile(.75)
iqr_pedi=q3_pedi-q1_pedi

q1_Age=df['Age'].quantile(.25)
q3_Age=df['Age'].quantile(.75)
iqr_Age=q3_Age-q1_Age

df['pregs']=np.where(df['pregs']<q1_pregs-1.5*iqr_pregs,df['pregs'].median(),df['pregs'])
df['pregs']=np.where(df['pregs']>q3_pregs+1.5*iqr_pregs,df['pregs'].median(),df['pregs'])

df['plas']=np.where(df['plas']<q1_plas-1.5*iqr_plas,df['plas'].median(),df['plas'])
df['plas']=np.where(df['plas']>q3_plas+1.5*iqr_plas,df['plas'].median(),df['plas'])

df['pres']=np.where(df['pres']<q1_pres-1.5*iqr_pres,df['pres'].median(),df['pres'])
df['pres']=np.where(df['pres']>q3_pres+1.5*iqr_pres,df['pres'].median(),df['pres'])

df['skin']=np.where(df['skin']<q1_skin-1.5*iqr_skin,df['skin'].median(),df['skin'])
df['skin']=np.where(df['skin']>q3_skin+1.5*iqr_skin,df['skin'].median(),df['skin'])

df['test']=np.where(df['test']<q1_test-1.5*iqr_test,df['test'].median(),df['test'])
df['test']=np.where(df['test']>q3_test+1.5*iqr_test,df['test'].median(),df['test'])

df['BMI']=np.where(df['BMI']<q1_BMI-1.5*iqr_BMI,df['BMI'].median(),df['BMI'])
df['BMI']=np.where(df['BMI']>q3_BMI+1.5*iqr_BMI,df['BMI'].median(),df['BMI'])

df['pedi']=np.where(df['pedi']<q1_pedi-1.5*iqr_pedi,df['pedi'].median(),df['pedi'])
df['pedi']=np.where(df['pedi']>q3_pedi+1.5*iqr_pedi,df['pedi'].median(),df['pedi'])

df['Age']=np.where(df['Age']<q1_Age-1.5*iqr_Age,df['Age'].median(),df['Age'])
df['Age']=np.where(df['Age']>q3_Age+1.5*iqr_Age,df['Age'].median(),df['Age'])

print("Minimum and Maximum before normalisation")
print(df[['pregs','plas','pres','skin','test','BMI','pedi','Age']].min())
print(df[['pregs','plas','pres','skin','test','BMI','pedi','Age']].max())

# part a
df1=df.copy()
def nor(x,min,max):
    p= (((x-min)/(max-min))*7) + 5
    return p

for i in df1 :
  m = df1[i].min()
  M = df1[i].max()
  for j in range(len(df1[i])) :
    df1.loc[j,i] = (df1[i][j] - m )*(7)/(M-m) + 5

print("Minimum and Maximisation after normalisation")
print(df1[['pregs','plas','pres','skin','test','BMI','pedi','Age']].min())
print(df1[['pregs','plas','pres','skin','test','BMI','pedi','Age']].max())

# part b
print("Mean and Standard Dev. before standardization")
print(df[['pregs','plas','pres','skin','test','BMI','pedi','Age']].mean())
print(df[['pregs','plas','pres','skin','test','BMI','pedi','Age']].std())

df2=df.copy()

for i in df2 :
    m = df2[i].mean()
    s = df2[i].std()
    for j in range(len(df2[i])) :
        df2.loc[j,i] = (df2[i][j] - m )/s

print("Mean and Standard Dev. after standardization")
print(df2[['pregs','plas','pres','skin','test','BMI','pedi','Age']].mean())
print(df2[['pregs','plas','pres','skin','test','BMI','pedi','Age']].std())

# Q2
def Q2():
    mean = [0, 0]
    cov = [[13, -3], [-3, 5]]
    print("Sample of Data Generated by given function")
    D = np.random.multivariate_normal(mean, cov, 1000)
    print(D)
    a, b = [], []
    for i in D:
        a.append(i[0])
        b.append(i[1])
    # Plot of data point:
    # Eign values and Eign Vectors:
    eignvalues, eignvecs = np.linalg.eig(cov)
    c = np.array([eignvecs[0][0], eignvecs[1][0]])
    d = np.array([eignvecs[0][1], eignvecs[1][1]])
    j = np.array([c, d])
    plt.scatter(a, b, label='orignal data points')
    plt.title('Plot of original data points')
    plt.legend()
    plt.show()
    vc = np.array([[0, 0, eignvalues[0] * eignvecs[0][0], eignvalues[0] * eignvecs[1][0]]])
    vc1 = np.array([[0, 0, eignvalues[1] * eignvecs[0][1], eignvalues[1] * eignvecs[1][1]]])
    x0, y0, u0, v0 = zip(*vc)
    x1, y1, u1, v1 = zip(*vc1)
    plt.scatter(a, b, label='original data points')
    plt.legend()
    plt.quiver(x0, y0, u0, v0, angles='xy', scale_units='xy', scale=1, width=0.002)
    plt.quiver(x1, y1, u1, v1, angles='xy', scale_units='xy', scale=1, width=0.002, label='Eign Vectors')
    plt.xticks(np.arange(-12, 15, 2))
    plt.yticks(np.arange(-10, 10, 2))
    plt.legend()
    plt.show()
    pc_list = [[], []]
    for t in range(2):
        vc = np.array([[0, 0, eignvalues[0] * eignvecs[0][0], eignvalues[0] * eignvecs[1][0]]])
        vc1 = np.array([[0, 0, eignvalues[1] * eignvecs[0][1], eignvalues[1] * eignvecs[1][1]]])
        x0, y0, u0, v0 = zip(*vc)
        x1, y1, u1, v1 = zip(*vc1)
        plt.scatter(a, b, label='original data points')
        plt.legend()
        plt.quiver(x0, y0, u0, v0, angles='xy', scale_units='xy', scale=1, width=0.002)
        plt.quiver(x1, y1, u1, v1, angles='xy', scale_units='xy', scale=1, width=0.002, label='Eign Vectors')
        plt.legend()
        # Projection of data points:
        projection_points_x = []
        projection_points_y = []
        for q in D:
            p = np.dot(q, j[t]) / np.linalg.norm(j[t])
            projection_points_x.append(p * j[t][0] / np.linalg.norm(j[t]))
            projection_points_y.append(p * j[t][1] / np.linalg.norm(j[t]))
            pc_list[t].append(p)
        plt.scatter(projection_points_x, projection_points_y, marker='x', color="#FF6A6A",
                    label='Projected data points')
        plt.legend()
        plt.xticks(np.arange(-12, 15, 2))
        plt.yticks(np.arange(-10, 10, 2))
        plt.xlabel("X-axis")
        plt.ylabel("Y-axis")
        plt.title("Scatter Plot of 2D 1000 sample generated data")
        plt.show()

    # performing reconstruction of data from two eignvectors
    print("After performing PCA and reconstruction: ")
    data_collect = []
    for m in range(len(D)):
        table = []
        for y in range(2):
            table.append(pc_list[0][m] * eignvecs[y][0] + pc_list[1][m] * eignvecs[y][1])
        data_collect.append(table)

    print(np.array(data_collect))
    # Estimating reconstruction error:
    error_table = []
    new = 0
    for f in range(len(D)):
        new =   (((D[f][0] - data_collect[f][0]) ** 2) + ((D[f][1] - data_collect[f][1]) ** 2)) **.5
        error_table.append(round(new,3))

    print(np.array(error_table))
print(Q2())

# Q3
df2 = df2.iloc[:,:8]

# part a
#a1 = np.dot(np.transpose(df2),df2)
a1 = df2.corr()
eigval,v=np.linalg.eig(a1)

eval_l = list(eigval)
eval_l.sort(reverse=True)

pc=PCA(n_components=2)
pc.fit(df2)
rd=pc.fit_transform(df2)
rd_dataf=pd.DataFrame(rd,columns=['A','B'])

print("Variance is: ",pc.explained_variance_)
print("Eigen values are: ",eval_l[0],eval_l[1])

#df3 = np.dot(df2,v[:,0:2])

# Scatterplot of reduced data
#plt.scatter(df3[:,0],df3[:,1])
plt.scatter(rd_dataf['A'],rd_dataf['B'])
plt.title('Scatterplot of transformed data',size=22)
plt.show()

# part b

l=[1,2,3,4,5,6,7,8]
plt.bar(l,eval_l)
plt.title('eigonvalues in descending order',size=22)
plt.show()

# part c
error=[]
for i in range(1,9):
    pca=PCA(n_components=i)
    pca.fit(df2)
    x_pca = pca.transform(df2)
    x_inv = pca.inverse_transform(x_pca)
    X_error = 0
    for j in range(len(df2)):
        s = 0
        for k in range(8):
            s += (x_inv[j][k]-df2.loc[j][k])**2
        X_error += s**0.5
    error.append(X_error/len(df2))

plt.plot([i for i in range(1,9)],error,'r',marker='o')
plt.xlabel("No. of componenets (l)")
plt.ylabel("Reconstruction Error in Eucledian Distance")
plt.title("Plot of Recontruction error vs No. of Components")
plt.show()

for i in range(2,9):
    pca0 = PCA(n_components=i, random_state=50)
    pca2_results0 = pd.DataFrame(pca0.fit_transform(df2))
    pca2_proj_back0=pca0.inverse_transform(pca2_results0)
    print("Covariance matrix of reduced data for l = ",i)
    print(round(pca2_results0.cov(), 3))

# part d
print("Covariance matrix of original data")
print(df2.cov())
